<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="UTF-8">
</head>

<body>

  <img id = "tileset" width = "0" height = "0" src = "assets/tileset.png">
  <img id = "char" width = "0" height = "0" src = "assets/char3.png">
  <canvas id="gameArea"> </canvas>
  <script src="extern/amplify.core.min.js"></script>
  <script src="extern/pathfinding-browser.min.js"></script>

  <script src="time.js"></script>
  <script src="gamestate.js"></script>
  <script src="misc.js"></script>
  <script src="sprite.js"></script>
  <script src="map.js"></script>
  <script src="character.js"></script>
  <script src="mouse.js"></script>
  <script src="notify.js"></script>
  <script src="menu.js"></script>

  <script>

  var tmpMap = [[1,1,17,16,16,16,24,16,16,16,16,16,19],
  [1,1,15,30,0,0,14,30,0,0,0,0,15],
  [17,16,20,30,0,0,0,0,0,0,0,0,15],
  [15,30,0,0,0,0,12,30,0,0,0,0,15],
  [40,50,0,0,0,0,18,16,19,30,0,0,15],
  [15,30,0,0,0,0,0,0,15,30,0,0,15],
  [40,50,0,0,0,0,0,0,15,30,0,0,15],
  [15,30,0,0,0,0,0,0,15,30,0,0,15],
  [18,16,19,30,0,0,0,0,15,30,0,0,15],
  [1,1,15,30,0,0,0,0,15,30,0,0,15],
  [1,1,18,16,16,16,16,16,22,16,16,16,20]];

  //Setup global variables
  var TILE_SIZE = 32;
  // Determine required screen size
  var SUPPORTED_RESOLUTIONS = [[1920,1080],[1280,720],[800,600]];
  var canvas = document.getElementById("gameArea");
  var it = 1;
  while (window.innerHeight < SUPPORTED_RESOLUTIONS[it][1]){it++;}
  canvas.width = SUPPORTED_RESOLUTIONS[it][0];
  canvas.height = SUPPORTED_RESOLUTIONS[it][1];

  var cameraScreenPosition = [0.5 * (canvas.width - TILE_SIZE), 0.5 * (canvas.height - TILE_SIZE)];
  var cameraMapPosition = [2.0, 2.0];

  var  animations = {
    down: {frames: [3], speed: 0},
    left: {frames: [6], speed: 0},
    right: {frames: [9], speed: 0},
    up: {frames: [0], speed: 0},
    walkdown: {frames: [3, 4, 3, 5], speed: 0.2},
    walkleft: {frames: [6, 7, 6, 8], speed: 0.2},
    walkright: {frames: [9, 10, 9, 11], speed: 0.2},
    walkup: {frames: [0, 1, 0, 2], speed: 0.2}
  };

  // Names for testing
  var names = ["Dave","Chris","Mike", "Jack","John"];

  // World class
  var World = (function () {

    var World = function(_canvas) {
      this.map = 0;
      this.maps = [new Map2D(tmpMap, "test", tileset)];
      this.pause = false;
      this.entities = [];
      this.ui = [];
      for (var i=0; i < 5; i++)
      {
        this.entities.push(new Character(this.maps[this.map],names[i]));
      }
      this.ctx = _canvas.getContext("2d");
      this.width = _canvas.width;
      this.height = _canvas.height;
      this.bgcolor = "#54AB47";

      var self = this;

      amplify.subscribe("popup-text", function (x, y, text, fun) {
        self.createNotify(x, y, text, fun);
      });

      amplify.subscribe("popup-menu", function (x, y, menu) {
        self.createMenu(x, y, menu);
      });
    };

    World.prototype = {
      createNotify: function (x, y, text, fun) {
        this.ui.push(new Notify(x, y, text, fun));
      },
      createMenu: function (x, y, menu) {
        this.ui.push(new Menu(x, y, menu));
      },
      pauseGame: function(val) {
        if (val == true)
        {
          this.pause = true;
          amplify.publish( "pause", true);
        }
        else {
          this.pause = false;
          amplify.publish( "pause", false);
        }
      },
      update: function () {
        // Delete ui elements which are no longer visible
        var i = this.ui.length;
        while (i--)
        {
          if (!this.ui[i].visible)
          this.ui.splice(i, 1);
        }

        // Pause when ui elements active
        if (this.ui.length > 0)
          this.pauseGame(true);
        else
          this.pauseGame(false);

        if (!this.pause)
        {
          for (var i=0; i < this.entities.length;  i++)
          {
            this.entities[i].update();
          }
        }
      },
      draw: function (dt) {
        // Draw backgroud
        this.ctx.fillStyle = this.bgcolor;
        this.ctx.fillRect(0, 0, this.width, this.height);

        // Draw map
        this.maps[this.map].draw(this.ctx);

        // Sort entities by y position
        var drawOrder = [];
        for (i=0; i < this.entities.length; i++)
          drawOrder.push([i, this.entities[i].sprite.y]);

        drawOrder.sort(function(a, b){
          return a[1]-b[1];
        });

        // Draw entities
        for (j=0; j < this.entities.length; j++) {
          var i = drawOrder[j][0];
          this.entities[i].draw(this.ctx);
        }

        // Draw FPS
        this.ctx.fillStyle = "black";
        this.ctx.font = "25px Arial";
        var time = Time.getCurrent();
        var timeString = "Y: "+time[0]+" M: "+time[1]+ " D: "+time[2];
        if (this.pause)
          this.ctx.fillText(timeString+" FPS: "+Math.floor(1/dt) + " (Paused)",10,20);
        else
          this.ctx.fillText(timeString+" FPS: "+Math.floor(1/dt),10,20);

        // Draw any ui elements
        for (k=0; k < this.ui.length;k++)
          this.ui[k].draw(this.ctx);
      }
    }

    return World;
  })();

  var world = new World(canvas);
  var lastTime;

  canvas.addEventListener("mousedown", function(e){
    amplify.publish( "mousedown", {ev:e, offsetLeft: canvas.offsetLeft, offsetTop: canvas.offsetTop});
  }, false);

  canvas.addEventListener("mousemove", function(e){
    amplify.publish( "mousemove", {ev:e, offsetLeft: canvas.offsetLeft, offsetTop: canvas.offsetTop});
  }, false);

  function gameLoop() {
    var now = Date.now();
    var dt = (now - lastTime) / 1000.0; // Time in seconds since last

    world.update();

    if (!isNaN(dt)) {
      if (!world.pause)
      Time.tick(dt);

      amplify.publish( "dt", dt);
    }

    world.draw(dt);

    lastTime = now;

    requestAnimationFrame(gameLoop);
  }

  requestAnimationFrame(gameLoop);


  </script>

</body>
</html>
