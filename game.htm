<!DOCTYPE HTML>
<html lang="en">
<head>
<meta charset="UTF-8">
</head>

<body>

<img id = "tileset" width = "0" height = "0" src = "assets/tileset.png">
<img id = "char" width = "0" height = "0" src = "assets/character.png">
<canvas id="gameArea"> </canvas>
<script src="extern/amplify.core.min.js"></script>
<script src="extern/pathfinding-browser.min.js"></script>
<script src="maps.js"></script>
<script>
//Setup initial camera parameters
var TILE_SIZE = 32;
// Determine required screen size
var SUPPORTED_RESOLUTIONS = [[1920,1080],[1280,720]];
var canvas = document.getElementById("gameArea");
var it = 1;
//while (window.innerHeight < SUPPORTED_RESOLUTIONS[it][1]) {it++;
//}

canvas.width = SUPPORTED_RESOLUTIONS[it][0];
canvas.height = SUPPORTED_RESOLUTIONS[it][1];
var cameraScreenPosition = [0.5 * (canvas.width - TILE_SIZE), 0.5 * (canvas.height - TILE_SIZE)];
var cameraMapPosition = [2.0, 2.0];

// Return random int in range [min, max]
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}


// Example sprite animations
var  animations = {
       down: [0],
       left: [4],
       right: [8],
       up: [12],
       walkdown: [0, 1, 2 , 3],
       walkleft: [4, 5, 6, 7],
       walkright: [8, 9, 10, 11],
       walkup: [12, 13, 14, 15]
};

// speeds are in terms of seconds/frame
var speeds = {down:0, left:0, right:0, up:0, walkdown:0.2, walkleft:0.2, walkright:0.2, walkup: 0.2};

// Sprite class
var Sprite = (function () {

  var Sprite = function(_spritesheet, _swidth, _sheight, _width, _height, _animations, _state, _speed) {
    this.spritesheet = _spritesheet;
    // Should get the below two from the image!
    this.width = _width;
    this.height = _height;
    this.spriteWidth = _swidth;
    this.spriteHeight = _sheight;
    this.speed = _speed;
    this.animations = _animations;
    this.dt = 0;
    this.time = 0;
    this.state = _state;
    this.frame = 0; //move along the animation
    var self = this;
    amplify.subscribe( "dt", function (data) {
      self.tick(data);
    });
  };

  Sprite.prototype = {
    tick: function(dt) {
      this.time += dt;
      if (this.time >= this.speed[this.state])
      {
          this.frame = (this.frame + 1) % this.animations[this.state].length;
          this.time = 0;
      }
    },
    setState: function(state) {
      if (state != this.state)
      {
        this.state = state;
        this.frame = 0;
        self.time = 0;
      }
    },
    getX: function() {
      return this.animations[this.state][this.frame]*this.spriteWidth % this.width;
    },
    getY: function() {
      return this.spriteHeight*Math.floor(this.animations[this.state][this.frame]/(this.width/this.spriteWidth));
    }
  }

  return Sprite;
})();


// Maps class
var Map2D = (function () {

  var Map2D = function(_layout, _name, _tileset) {
    this.occupied = [];
    this.layout = _layout; // Not final solution for map storage!
    this.name = _name;
    this.width = this.layout.length;
    this.height = this.layout[0].length;
    this.tileset = _tileset;
    this.gridOrig = new PF.Grid(this.width, this.height);
    // Create the grid for collisons for use by the path finder
    for (var i=0; i < this.width; i++) {
      for (var j=0; j < this.height; j++) {
        if (this.layout[i][j] == 0)
        {
          this.gridOrig.setWalkableAt(i, j, true);
        }
        else {
          this.gridOrig.setWalkableAt(i, j, false);
        }
      }
    }
    this.finder = new PF.AStarFinder();
  };

  Map2D.prototype = {
    collision: function (x, y) {
      if (this.layout[x][y] != 0) {
        return true;
      }

      return false;
    },
    generatePath: function(x0, y0, x, y) {
      var grid = this.gridOrig.clone();
      return this.finder.findPath(x0, y0, x, y, grid);
    },
    loadTileset: function(){
      // Preload tileset
    }
  }

  return Map2D;
})();

// World class
var World = (function () {

  var World = function(_canvas) {
    this.map = 0;
    this.maps = [new Map2D(mapA, "test", tileset)];
    this.entities = [];
    for (var i=0; i < 5; i++)
    {
      this.entities.push(new Character(this.maps[this.map]));
    }
    this.ctx = _canvas.getContext("2d");
    this.width = _canvas.width;
    this.height = _canvas.height;
    this.bgcolor = "#54AB47";
  };

  World.prototype = {
    update: function () {
      for (var i=0; i < this.entities.length;  i++)
      {
        this.entities[i].update();
      }
    },
    draw: function (dt) {
      // Clear canvas
      //this.ctx.clearRect(0, 0, this.width, this.height);

      // Draw backgroud
      this.ctx.fillStyle = this.bgcolor;
      this.ctx.fillRect(0, 0, this.width, this.height);

      // Draw map
      for (i = 0; i < this.maps[this.map].width; i++) {
        var x = cameraScreenPosition[0] + TILE_SIZE*(i - cameraMapPosition[0]);
        for (j = 0; j < this.maps[this.map].height; j++) {
          var y = cameraScreenPosition[1] + TILE_SIZE*(j - cameraMapPosition[1]);
          this.ctx.drawImage(this.maps[this.map].tileset, (this.maps[this.map].layout[i][j]%10)*TILE_SIZE, Math.floor(this.maps[this.map].layout[i][j]/10.0)*TILE_SIZE, TILE_SIZE, TILE_SIZE, x, y, TILE_SIZE, TILE_SIZE);
        }
      }

      // Draw entities
      for (i=0; i < this.entities.length; i++) {
        var x = cameraScreenPosition[0] + TILE_SIZE*(this.entities[i].x - cameraMapPosition[0]);
        var y = cameraScreenPosition[1] + TILE_SIZE*(this.entities[i].y - cameraMapPosition[1]);
        //this.ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        this.ctx.drawImage(this.entities[i].sprite.spritesheet, this.entities[i].sprite.getX(), this.entities[i].sprite.getY(), this.entities[i].sprite.spriteWidth, this.entities[i].sprite.spriteHeight, x, y - (this.entities[i].sprite.spriteHeight-TILE_SIZE), this.entities[i].sprite.spriteWidth, this.entities[i].sprite.spriteHeight);

      }
      this.ctx.fillStyle = "black";
      this.ctx.font = "25px Arial";
      this.ctx.fillText("FPS: "+Math.floor(1/dt),10,20);
    }
  }

  return World;
})();

// Character class
var Character = (function () {

  var Character = function(_map) {
    this.map = _map;
    this.charname = "";
    this.level = 0;
    this.efficiency = 0;
    this.experiments = 0;
    this.theory = 0;
    this.computational = 0;
    this.sprite = new Sprite(char, 32, 32*1.5,32*4,32*1.5*4,  animations, "walkdown", speeds);
    var rpos = this.randomPosition();
    this.x = rpos[0]  // Current y tile
    this.y = rpos[1]; // Current y tile
    this.Tx = 0; // target x tile (for blocking)
    this.Ty = 0; // target y tile (for blocking)
    this.direction = 1; // 0 = up, 1 = down, 2 = left, 3 = right
    this.path = [];
    this.dt = 0;
    this.speed = 1; // Movement speed - pixels/second
    var self = this;
    // subscribe to dt
    amplify.subscribe( "dt", function (data) {
      self.dt = data;
    });

    amplify.subscribe( "mousedown", function(ev) {
      self.input(ev);
    });
  };

  Character.prototype = {
    input: function (data) {
      var x = data["ev"].pageX - data["offsetLeft"];
      var y = data["ev"].pageY - data["offsetTop"];

      var xPos = cameraScreenPosition[0] + TILE_SIZE*(this.x - cameraMapPosition[0]);
      var yPos = cameraScreenPosition[1] + TILE_SIZE*(this.y - cameraMapPosition[1])-(this.sprite.spriteHeight-TILE_SIZE);

      if (x >= xPos && x <= (xPos+this.sprite.spriteWidth) && y >= yPos  && y <= (yPos+this.sprite.spriteHeight))
      {
        // Testing
        this.randomMove();
      }
    },
    update: function () {
      // If the path isn't empty have the character follow it.
      if (this.path.length != 0)
      {
        if (this.x == this.path[0][0] && this.y == this.path[0][1]) {
          this.path.shift();
        }

        if (this.path.length != 0) {
          // Move the character position along the path
          if (this.x - this.path[0][0] > 0) {
            if (this.x - (this.speed*this.dt) < this.path[0][0]) {
              this.x = this.path[0][0];
            }
            else {
              this.x -= (this.speed*this.dt);
            }
            this.sprite.setState("walkleft");
            this.direction = 2;
          }
          else if (this.x - this.path[0][0] < 0) {
            if (this.x + (this.speed*this.dt) > this.path[0][0]) {
              this.x = this.path[0][0];
            }
            else {
              this.x += (this.speed*this.dt);
            }
            this.sprite.setState("walkright");
            this.direction = 3;
          }
          else if (this.y - this.path[0][1] > 0) {
            if (this.y - (this.speed*this.dt) < this.path[0][1]) {
              this.y = this.path[0][1];
            } else {
              this.y -= (this.speed*this.dt);
            }
            this.sprite.setState("walkup");
            this.direction = 0;
          }
          else if (this.y - this.path[0][1] < 0) {
            if (this.y + (this.speed*this.dt) > this.path[0][1]) {
              this.y = this.path[0][1];
            }
            else {
              this.y += (this.speed*this.dt);
            }
            this.sprite.setState("walkdown");
            this.direction = 1;
          }
        }
      } else {
        if (this.direction == 1) {
          this.sprite.setState("down");
        }
        else if (this.direction == 0) {
          this.sprite.setState("up");
        }
        else if (this.direction == 3) {
          this.sprite.setState("right");
        }
        else if (this.direction == 2) {
          this.sprite.setState("left");
        }
      }

    },
    randomPosition: function() {
      // Move to random position - testing
      tx = 0;
      ty = 0;
      do{
        tx = getRandomInt(0,this.map.width-1);
        ty = getRandomInt(0,this.map.height-1);
      } while (this.map.collision(tx, ty));

      return [tx, ty];
    },
    randomMove: function() {
      var pos = this.randomPosition();
      this.move(pos[0], pos[1]);
    },
    move: function(xDest, yDest) {
      this.path = this.map.generatePath(this.x, this.y, xDest, yDest);
    },
  }

  return Character;
})();

var world = new World(canvas);
var lastTime;

canvas.addEventListener("mousedown", function(e){
  amplify.publish( "mousedown", {ev:e, offsetLeft: canvas.offsetLeft, offsetTop: canvas.offsetTop});
}, false);

function gameLoop() {
  var now = Date.now();
  var dt = (now - lastTime) / 1000.0; // Time since last
  if (!isNaN(dt))
  {
    amplify.publish( "dt", dt);
  }

  world.update();
  world.draw(dt);

  lastTime = now;
  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);


</script>

</body>
</html>
