<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="UTF-8">
</head>

<body>

  <img id = "tileset" width = "0" height = "0" src = "assets/tileset.png">
  <img id = "char" width = "0" height = "0" src = "assets/char3.png">
  <canvas id="gameArea"> </canvas>
  <script src="extern/amplify.core.min.js"></script>
  <script src="extern/pathfinding-browser.min.js"></script>

  <script src="misc.js"></script>
  <script src="sprite.js"></script>
  <script src="map.js"></script>
  <script src="character.js"></script>
  <script src="mouse.js"></script>
  <script src="notify.js"></script>
  <script src="menu.js"></script>
  <script>

  var tmpMap = [[1,1,17,16,16,16,24,16,16,16,16,16,19],
  [1,1,15,30,0,0,14,30,0,0,0,0,15],
  [17,16,20,30,0,0,0,0,0,0,0,0,15],
  [15,30,0,0,0,0,12,30,0,0,0,0,15],
  [40,50,0,0,0,0,18,16,19,30,0,0,15],
  [15,30,0,0,0,0,0,0,15,30,0,0,15],
  [40,50,0,0,0,0,0,0,15,30,0,0,15],
  [15,30,0,0,0,0,0,0,15,30,0,0,15],
  [18,16,19,30,0,0,0,0,15,30,0,0,15],
  [1,1,15,30,0,0,0,0,15,30,0,0,15],
  [1,1,18,16,16,16,16,16,22,16,16,16,20]];

  //Setup initial camera parameters
  var TILE_SIZE = 32;
  // Determine required screen size
  var SUPPORTED_RESOLUTIONS = [[1920,1080],[1280,720]];
  var canvas = document.getElementById("gameArea");
  var it = 1;
  //while (window.innerHeight < SUPPORTED_RESOLUTIONS[it][1]) {it++;
  //}

  canvas.width = SUPPORTED_RESOLUTIONS[it][0];
  canvas.height = SUPPORTED_RESOLUTIONS[it][1];
  var cameraScreenPosition = [0.5 * (canvas.width - TILE_SIZE), 0.5 * (canvas.height - TILE_SIZE)];
  var cameraMapPosition = [2.0, 2.0];

var  animations = {
  down: {frames: [3], speed: 0},
  left: {frames: [6], speed: 0},
  right: {frames: [9], speed: 0},
  up: {frames: [0], speed: 0},
  walkdown: {frames: [3, 4, 3, 5], speed: 0.2},
  walkleft: {frames: [6, 7, 6, 8], speed: 0.2},
  walkright: {frames: [9, 10, 9, 11], speed: 0.2},
  walkup: {frames: [0, 1, 0, 2], speed: 0.2}
};

var names = ["Dave","Chris","Mike", "Jack","John"];
// World class
var World = (function () {

  var World = function(_canvas) {
    this.map = 0;
    this.maps = [new Map2D(tmpMap, "test", tileset)];
    this.pause = false;
    this.entities = [];
    this.ui = [];
    for (var i=0; i < 5; i++)
    {
      this.entities.push(new Character(this.maps[this.map],names[i]));
    }
    this.ctx = _canvas.getContext("2d");
    this.width = _canvas.width;
    this.height = _canvas.height;
    this.bgcolor = "#54AB47";

    var self = this;

    amplify.subscribe("popup-text", function (x, y, text, fun) {
      self.createNotify(x, y, text, fun);
    });

    amplify.subscribe("popup-menu", function (x, y, menu) {
      self.createMenu(x, y, menu);
    });
  };

  World.prototype = {
    createNotify: function (x, y, text, fun) {
      this.ui.push(new Notify(x, y, text, fun));
    },
    createMenu: function (x, y, menu) {
      this.ui.push(new Menu(x, y, menu));
    },
    cameraPosition: function (cameraMPos, cameraSPos) {
      amplify.publish( "camera-pos", cameraMPos, cameraSPos);
    },
    pauseGame: function(val) {
      if (val == true)
      {
        this.pause = true;
        amplify.publish( "pause", true);
      }
      else {
        this.pause = false;
        amplify.publish( "pause", false);
      }
    },
    update: function () {
      // Delete ui elements which are no longer visible
      var i = this.ui.length;
      while (i--)
      {
        if (!this.ui[i].visible)
         this.ui.splice(i, 1);
      }

      // Pause when ui elements active
      if (this.ui.length > 0)
        this.pauseGame(true);
      else
        this.pauseGame(false);

      if (!this.pause)
      {
        for (var i=0; i < this.entities.length;  i++)
        {
          this.entities[i].update();
        }
      }
    },
    draw: function (dt) {
      // Draw backgroud
      this.ctx.fillStyle = this.bgcolor;
      this.ctx.fillRect(0, 0, this.width, this.height);

      // Draw map
      for (i = 0; i < this.maps[this.map].width; i++) {
        var x = cameraScreenPosition[0] + TILE_SIZE*(i - cameraMapPosition[0]);
        for (j = 0; j < this.maps[this.map].height; j++) {
          var y = cameraScreenPosition[1] + TILE_SIZE*(j - cameraMapPosition[1]);
          this.ctx.drawImage(this.maps[this.map].tileset, (this.maps[this.map].layout[i][j]%10)*TILE_SIZE, Math.floor(this.maps[this.map].layout[i][j]/10.0)*TILE_SIZE, TILE_SIZE, TILE_SIZE, x, y, TILE_SIZE, TILE_SIZE);
        }
      }

      // Sort entities by y position
      var drawOrder = [];
      for (i=0; i < this.entities.length; i++)
      drawOrder.push([i, this.entities[i].sprite.y]);

      drawOrder.sort(function(a, b){
        return a[1]-b[1];
      });

      // Draw entities
      for (j=0; j < this.entities.length; j++) {
        var i = drawOrder[j][0];
        this.entities[i].draw(this.ctx);
      }

      // Draw FPS
      this.ctx.fillStyle = "black";
      this.ctx.font = "25px Arial";
      if (this.pause)
        this.ctx.fillText("FPS: "+Math.floor(1/dt) + " (Paused)",10,20);
      else
        this.ctx.fillText("FPS: "+Math.floor(1/dt),10,20);

      // Draw any ui elements
      for (k=0; k < this.ui.length;k++)
	     this.ui[k].draw(this.ctx);
    }
  }

  return World;
})();

var world = new World(canvas);
var lastTime;

world.cameraPosition(cameraMapPosition, cameraScreenPosition);

canvas.addEventListener("mousedown", function(e){
  amplify.publish( "mousedown", {ev:e, offsetLeft: canvas.offsetLeft, offsetTop: canvas.offsetTop});
}, false);

canvas.addEventListener("mousemove", function(e){
  amplify.publish( "mousemove", {ev:e, offsetLeft: canvas.offsetLeft, offsetTop: canvas.offsetTop});
}, false);

function gameLoop() {
  var now = Date.now();
  var dt = (now - lastTime) / 1000.0; // Time in seconds since last

  world.update();

  if (!isNaN(dt)) {
    amplify.publish( "dt", dt);
  }

  world.draw(dt);

  lastTime = now;

  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);


</script>

</body>
</html>
